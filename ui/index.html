<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>OP‑XY Conductor – UI</title>
    <style>
      body { font-family: -apple-system, system-ui, Segoe UI, Roboto, Helvetica, Arial, sans-serif; margin: 16px; color: #111; }
      h1 { margin: 0 0 8px; font-size: 18px; }
      .row { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; margin-bottom: 12px; }
      button { padding: 6px 10px; font-size: 14px; }
      input[type="number"] { width: 80px; padding: 4px; }
      #status { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; color: #444; }
      .tracks { display: grid; gap: 12px; margin-top: 12px; }
      .track { border: 1px solid #ddd; border-radius: 6px; padding: 8px; }
      .track h3 { margin: 0 0 6px; font-size: 14px; display: flex; justify-content: space-between; }
      .grid { display: grid; gap: 2px; }
      .cell { width: 16px; height: 16px; background: #eee; border-radius: 3px; cursor: pointer; }
      .cell.on { background: #5aa7ff; }
      .dk { font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size: 12px; background: #fafafa; padding: 6px; border-radius: 4px; border: 1px dashed #ddd; white-space: pre; overflow-x: auto; }
      .pill { font-size: 11px; padding: 2px 6px; border-radius: 999px; background: #f2f2f2; margin-left: 6px; }
    </style>
  </head>
  <body>
    <h1>OP‑XY Conductor – Local UI</h1>
    <div class="row">
      <label>BPM <input id="bpm" type="number" value="100" min="40" max="220" /></label>
      <button id="btnSetTempo">Set tempo (CC80)</button>
      <button id="btnReconnect">Reconnect</button>
      <span id="status"></span>
      <span id="conn" class="pill">connecting…</span>
      <span id="patch" class="pill"></span>
      <span id="pending" class="pill"></span>
    </div>

    <div class="row">
      <label><input id="applyNow" type="checkbox" /> apply now (structural)</label>
      <button id="btnClockInternal">Use internal clock</button>
      <button id="btnClockExternal">Use external clock</button>
      <button id="btnPlay">Play (internal)</button>
      <button id="btnStop">Stop (internal)</button>
      <span style="font-size:12px;color:#666">edits send as patches; structural applies next bar unless checked</span>
    </div>

    <div id="meta"></div>
    <div id="metrics" class="dk"></div>
    <div class="tracks" id="tracks"></div>
    <div id="automations"></div>

    <script>
      const wsBaseUrl = 'ws://127.0.0.1:8765';
      let ws; let lastDoc = null; let lastState = null; let lastMetrics = null; let reqId = 1; const pending = new Map(); let retryMs = 500; let pingTimer = null; let lastPingAt = 0; let lastDocVersion = 0; let lastSha = '';
      // Patch queue to serialize edits and avoid stale baseVersion
      const patchQueue = [];
      let inFlightPatch = null; // { id, ops, applyNow }
      const status = document.getElementById('status');
      function setStatus(s) { status.textContent = s; }

      function connect() {
        try { if (ws && (ws.readyState === 0 || ws.readyState === 1)) return; } catch(e){}
        ws = new WebSocket(wsBaseUrl);
        ws.onopen = () => {
          setStatus('WS connected'); retryMs = 500;
          try { send({type:'subscribe'}); send({type:'getDoc'}); send({type:'getState'}); } catch(e){}
          if (pingTimer) { clearInterval(pingTimer); }
          pingTimer = setInterval(() => { try { if (ws && ws.readyState === 1) { lastPingAt = performance.now(); send({type:'ping'}); } } catch(e){} }, 10000);
        };
        ws.onclose = () => {
          setStatus('WS disconnected'); if (pingTimer) { clearInterval(pingTimer); pingTimer = null; }
          setTimeout(connect, retryMs); retryMs = Math.min(retryMs * 2, 4000);
        };
        ws.onmessage = (ev) => {
          try { const msg = JSON.parse(ev.data); handle(msg); } catch {}
        };
      }

  function handle(msg) {
        if (msg.type === 'doc') { const payload = msg.payload; const sha = payload && payload.sha256 || ''; if (sha && sha===lastSha) { /* no redraw */ } else { lastSha = sha||lastSha; lastDoc = payload; lastDocVersion = parseInt(lastDoc.docVersion||0,10)||0; try { console.log('doc v', lastDocVersion, 'sha', sha.slice(0,8)); } catch(e){}; renderDoc(); } try { flushPatchQueue(); } catch(e){} }
        if (msg.type === 'state') { lastState = msg.payload; renderState(); renderAutomation(); }
        if (msg.type === 'metrics') { lastMetrics = msg.payload; renderMetrics(); }
        if (msg.type === 'error') {
          console.warn('ws error', msg.payload);
          const code = msg.payload && msg.payload.error;
          setStatus('WS error: ' + (code || 'unknown'));
          if (code === 'stale') { try { inFlightPatch = null; send({type:'getDoc'}); flushPatchQueue(); } catch(e){} }
        }
        if (msg.type === 'ack') { const id = msg.id; if (id && pending.has(id)) pending.delete(id); if (inFlightPatch && inFlightPatch.id === id) { inFlightPatch = null; } try { document.getElementById('patch').textContent='ok'; setTimeout(()=>{ const el=document.getElementById('patch'); if (el && el.textContent==='ok') el.textContent=''; }, 1200);} catch(e){} try { flushPatchQueue(); } catch(e){} }
        if (msg.type === 'hello') { /* protocol ok */ }
        if (msg.type === 'pong') { if (lastPingAt) { const rtt = Math.round(performance.now()-lastPingAt); try { document.getElementById('conn').textContent = `connected (${rtt}ms)`; } catch(e){} } }
  }

  // Minimal optimistic patch applier for common UI ops
  function optimisticApplyPatch(ops){
    if (!lastDoc || !lastDoc.json) return;
    const root = lastDoc.json;
    for (const op of ops){
      const p = op.path || '';
      const parts = p.split('/').filter(Boolean);
      if (parts[0] === 'tracks' && parts[2] === 'pattern' && parts[3] === 'steps'){
        const ti = parseInt(parts[1],10);
        const track = (root.tracks||[])[ti]; if (!track) continue;
        const steps = track.pattern && Array.isArray(track.pattern.steps) ? track.pattern.steps : (track.pattern.steps = []);
        if (op.op === 'add' && parts[4] === '-'){
          steps.push(JSON.parse(JSON.stringify(op.value)));
        } else if (op.op === 'remove' && parts.length === 5){
          const si = parseInt(parts[4],10);
          if (!Number.isNaN(si) && si >= 0 && si < steps.length) steps.splice(si,1);
        }
      } else if (parts[0] === 'tracks' && parts[2] === 'drumKit' && parts[3] === 'patterns' && parts.length === 6 && parts[5] === 'pattern'){
        const ti = parseInt(parts[1],10); const pi = parseInt(parts[4],10);
        const track = (root.tracks||[])[ti]; if (!track) continue;
        const patterns = track.drumKit && Array.isArray(track.drumKit.patterns) ? track.drumKit.patterns : null;
        if (patterns && !Number.isNaN(pi) && patterns[pi]) patterns[pi].pattern = String(op.value||'');
      }
    }
  }

      function send(obj) { if (!ws || ws.readyState !== 1) return; const id = reqId++; obj.id = id; if (obj.type && obj.type.startsWith('apply')) pending.set(id, obj); ws.send(JSON.stringify(obj)); return id; }

      function flushPatchQueue(){
        if (!ws || ws.readyState !== 1 || !lastDoc) return;
        if (inFlightPatch) return;
        if (patchQueue.length === 0) return;
        const next = patchQueue.shift();
        const baseVersion = parseInt(lastDoc.docVersion||0, 10) || 0;
        const m = { type:'applyPatch', payload: { baseVersion, ops: next.ops, applyNow: !!next.applyNow } };
        try { console.log('sendPatch', m); } catch(e){}
        const id = send(m);
        if (id) inFlightPatch = { id, ...next };
      }

      function sendPatch(ops, applyNow) {
        patchQueue.push({ ops, applyNow: !!applyNow });
        try { console.log('enqueuePatch', { queued: patchQueue.length, inFlight: !!inFlightPatch, ops }); } catch(e){}
        flushPatchQueue();
      }

      function renderMetrics() {
        const el = document.getElementById('metrics');
        if (!lastMetrics) { el.textContent = ''; return; }
        const eng = lastMetrics.engine || {}; const clk = lastMetrics.clock || {};
        const parts = [];
        parts.push(`engine: note_on=${eng.note_on||0} note_off=${eng.note_off||0} cc=${eng.cc||0} shed_cc=${eng.shed_cc||0}`);
        if (clk.p95_ms != null || clk.p99_ms != null) parts.push(`clock: p95=${clk.p95_ms||'?'}ms p99=${clk.p99_ms||'?'}ms`);
        if (clk.externalBpm != null) parts.push(`extBpm=${(Math.round(clk.externalBpm*10)/10).toFixed(1)}`);
        el.textContent = parts.join('  |  ');
      }

      function renderState() {
        if (!lastState) return;
        const { transport, bpm, barBeatTick, clockSource } = lastState;
        const bbt = barBeatTick ? ` beat=${barBeatTick.beat} tickInBar=${barBeatTick.tickInBar}/${barBeatTick.barTicks}` : '';
        setStatus(`clock=${clockSource||'internal'} transport=${transport} bpm=${bpm}${bbt}`);
        // Reflect external tempo changes in the BPM input as well
        const bpmInput = document.getElementById('bpm');
        // Do not clobber user's typing when the field has focus
        if (bpm && bpmInput && document.activeElement !== bpmInput) {
          bpmInput.value = (Math.round(bpm * 10) / 10).toFixed(1);
        }
        // (no clock toggle button in simplified UI)
      }

      function renderDoc() {
        if (!lastDoc) return;
        const wrap = document.getElementById('tracks');
        wrap.innerHTML = '';
        const meta = lastDoc.json.meta || {}; const spb = meta.stepsPerBar || 16; const ppq = meta.ppq || 96;
        document.getElementById('bpm').value = (lastState && lastState.bpm) || (meta.tempo || 120);
        const metaDiv = document.getElementById('meta');
        const p = lastDoc.path || 'loop.json';
        metaDiv.textContent = `loop=${p} docVersion=${lastDoc.docVersion} sha=${lastDoc.sha256?.slice(0,8)}`;

        const tracks = (lastDoc.json.tracks || []);
        tracks.forEach((tr, ti) => {
          const div = document.createElement('div'); div.className = 'track';
          const h3 = document.createElement('h3');
          const left = document.createElement('span'); left.textContent = `${tr.name || tr.id || 'Track'} (ch ${tr.midiChannel ?? 0})`;
          const right = document.createElement('span'); right.className = 'pill'; right.textContent = tr.type || 'sampler';
          h3.appendChild(left); h3.appendChild(right); div.appendChild(h3);

          // Steps grid (pattern.steps) — pitched tracks: render grid and a basic inspector
          const pat = tr.pattern || {}; const steps = Array.isArray(pat.steps) ? pat.steps : []; const bars = Math.max(1, pat.lengthBars || 1);
          const showStepsGrid = (!tr.drumKit);
          if (showStepsGrid) {
            const total = bars * spb;
            const vals = Array(total).fill(0);
            const stepIndexByAbs = new Map();
            let defaultPitch = null;
            steps.forEach((st, sIdx) => {
              const idx = st && typeof st.idx === 'number' ? (st.idx|0) : -1; const events = (st && st.events) || [];
              if (idx >= 0 && events.length) {
                vals[(idx % total)] = 1;
                stepIndexByAbs.set((idx % total), { arrIndex: sIdx, step: st });
                if (defaultPitch == null && typeof events[0].pitch === 'number') defaultPitch = events[0].pitch|0;
              }
            });
            if (defaultPitch == null) defaultPitch = 60; // C4 fallback
            // Always draw grid so user can add notes on empty patterns
            const grid = document.createElement('div'); grid.className = 'grid';
            grid.style.gridTemplateColumns = `repeat(${total}, 16px)`;
            for (let i=0;i<total;i++) {
              const c = document.createElement('div'); c.className = 'cell';
              const v = vals[i]; if (v>0){ c.classList.add('on'); }
              if (i % spb === 0) { c.style.outline = '1px solid #ddd'; }
              // Click: toggle note on/off at this step (no velocity UI)
              c.addEventListener('click', (ev) => {
                  const info = stepIndexByAbs.get(i);
                  if (info) {
                    // Existing: remove the whole step entry
                    const si = info.arrIndex;
                    const ops = [{ op: 'remove', path: `/tracks/${ti}/pattern/steps/${si}` }];
                    const applyNow = document.getElementById('applyNow').checked;
                    // Optimistic UI: apply locally then send
                    try { optimisticApplyPatch([ { op:'remove', path:`/tracks/${ti}/pattern/steps/${si}` } ]); renderDoc(); } catch(e){}
                    sendPatch(ops, applyNow);
                  } else {
                    // Empty: add a new step (default velocity handled backend; UI uses 100)
                    const newStep = { idx: i, events: [{ pitch: defaultPitch, velocity: 100, lengthSteps: 1 }] };
                    const ops = [{ op: 'add', path: `/tracks/${ti}/pattern/steps/-`, value: newStep }];
                    const applyNow = document.getElementById('applyNow').checked;
                    try { optimisticApplyPatch([{ op:'add', path:`/tracks/${ti}/pattern/steps/-`, value:newStep }]); renderDoc(); } catch(e){}
                    sendPatch(ops, applyNow);
                  }
              });
              // No shift+click behavior for now (keep UI simple)
              grid.appendChild(c);
            }
            div.appendChild(grid);

            // Basic Inspector for first event on a selected step index
            const insp = document.createElement('div'); insp.style.marginTop='6px'; insp.className='dk';
            insp.textContent = 'Inspector: select a step by clicking to add, then adjust fields via patches below.';
            const form = document.createElement('div'); form.style.display='flex'; form.style.gap='8px'; form.style.flexWrap='wrap'; form.style.marginTop='4px';
            const mk = (lab, id, def, w='70px') => { const span=document.createElement('span'); span.textContent=lab+': '; const inp=document.createElement('input'); inp.type='number'; inp.id=id; inp.value=def; inp.style.width=w; span.appendChild(inp); return [span, inp]; };
            const [vLab,vIn] = mk('velocity','inspVel','100');
            const [lLab,lIn] = mk('len','inspLen','1');
            const [rLab,rIn] = mk('ratchet','inspRat','1');
            const [pLab,pIn] = mk('prob','inspProb','1', '60px'); pIn.step='0.05'; pIn.min='0'; pIn.max='1';
            const [mLab,mIn] = mk('microMs','inspMicro','0');
            form.append(vLab,lLab,rLab,pLab,mLab);
            const applyBtn=document.createElement('button'); applyBtn.textContent='Apply to last added step';
            applyBtn.onclick = () => {
              // Heuristic: patch the last step entry for this track
              const steps = (lastDoc.json.tracks[ti].pattern.steps||[]); if (!steps.length) return;
              const si = steps.length-1; const base=`/tracks/${ti}/pattern/steps/${si}/events/0`;
              const ops=[]; const toInt = (x) => parseInt(String(x||'0'),10)||0; const toNum=(x)=>Number(String(x||'0'))||0;
              ops.push({op:'replace', path: base+'/velocity', value: toInt(vIn.value)});
              ops.push({op:'replace', path: base+'/lengthSteps', value: toInt(lIn.value)});
              ops.push({op:'replace', path: base+'/ratchet', value: Math.max(1,toInt(rIn.value))});
              ops.push({op:'replace', path: base+'/prob', value: Math.max(0, Math.min(1, toNum(pIn.value)))});
              ops.push({op:'replace', path: base+'/microshiftMs', value: toInt(mIn.value)});
              sendPatch(ops, false);
            };
            form.appendChild(applyBtn);
            insp.appendChild(form); div.appendChild(insp);
          }

          // DrumKit patterns – render only core parts by default; show others only if present in JSON
          if (tr.drumKit && Array.isArray(tr.drumKit.patterns)) {
            const specs = tr.drumKit.patterns;
            const normalize = (s) => String(s||'').toLowerCase();
            const alias = (k) => ({ 'ch':'closed_hat','oh':'open_hat','hh':'closed_hat' }[k]||k);
            // Preferred ordering for known parts
            const allOrder = ['kick','kick_alt','snare','snare_alt','rim','clap','tambourine','shaker','closed_hat','open_hat','pedal_hat','low_tom','mid_tom','high_tom','crash','ride','cowbell','conga_low','conga_high','guiro','metal','chi'];
            // Core six shown by default (clicking adds if missing)
            const core = ['kick','snare','closed_hat','open_hat','clap','ride'];
            let rows = core.map(id => ({ id, label: id.replace('_',' ') }));
            // Build map key-> {pattern, specIndex} for current bar = 1
            const byKey = new Map();
            for (const s of specs) {
              const key = alias(normalize(s.key||''));
              const bar = s.bar||1;
              if (!s.pattern || typeof s.pattern !== 'string') continue;
              if (bar !== 1) continue; // first pass: show bar 1
              byKey.set(key, { pattern: String(s.pattern), specIndex: specs.indexOf(s) });
            }
            // Only include additional rows if they appear in JSON; keep stable order
            const present = Array.from(new Set(specs.map(s => alias(normalize(s.key||'')))));
            const extras = present.filter(k => !core.includes(k));
            extras.sort((a,b) => (allOrder.indexOf(a) - allOrder.indexOf(b)) || a.localeCompare(b));
            rows = rows.concat(extras.map(id => ({ id, label: id.replace('_',' ') })));
            // Container
            const cont = document.createElement('div');
            cont.style.marginTop = '8px';
            // Render rows
            rows.forEach(r => {
              const ent = byKey.get(r.id);
              const had = !!ent;
              const patt = (ent ? ent.pattern : '.'.repeat(spb));
              const specIndex = ent ? ent.specIndex : -1;
              const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.margin='2px 0';
              const lab = document.createElement('div'); lab.textContent = r.label; lab.style.width='64px'; lab.style.textAlign='right'; lab.style.fontSize='12px'; lab.style.color='#555';
              row.appendChild(lab);
              const g = document.createElement('div'); g.className='grid'; g.style.gridTemplateColumns = `repeat(${spb}, 16px)`;
              for (let i=0;i<spb;i++){
                const c = document.createElement('div'); c.className='cell';
                if (i < patt.length && patt[i] === 'x') c.classList.add('on');
                if (i % spb === 0) c.style.outline='1px solid #ddd';
                // Click to toggle drum hit in pattern string
                c.addEventListener('click', () => {
                  let chars = patt.split('');
                  if (i < chars.length) {
                    chars[i] = (chars[i] === 'x') ? '.' : 'x';
                  }
                  const next = chars.join('');
                  let ops;
                  if (had) {
                    ops = [{ op: 'replace', path: `/tracks/${ti}/drumKit/patterns/${specIndex}/pattern`, value: next }];
                  } else {
                    // Add a new spec row
                    const spec = { bar: 1, key: r.id, pattern: next, vel: 100 };
                    ops = [{ op: 'add', path: `/tracks/${ti}/drumKit/patterns/-`, value: spec }];
                  }
                  const applyNow = document.getElementById('applyNow').checked; // structural; default next bar
                  try {
                    if (had) {
                      optimisticApplyPatch([{ op:'replace', path:`/tracks/${ti}/drumKit/patterns/${specIndex}/pattern`, value: next }]);
                    } else {
                      optimisticApplyPatch([{ op:'add', path:`/tracks/${ti}/drumKit/patterns/-`, value: { bar:1, key:r.id, pattern: next, vel:100 } }]);
                    }
                    renderDoc();
                  } catch(e){}
                  sendPatch(ops, applyNow);
                });
                g.appendChild(c);
              }
              row.appendChild(g); cont.appendChild(row);
            });
            div.appendChild(cont);
          }

          wrap.appendChild(div);
        });
        renderAutomation();
      }

      // Automation panel: show current CC values for ccLanes per track, live
      function renderAutomation() {
        const root = lastDoc && lastDoc.json; if (!root) return;
        const contId = 'automations'; const host = document.getElementById(contId);
        if (!host) return; host.innerHTML = '';
        const state = lastState || {}; const ccNow = state.ccNow || {}; // { ch: { ctrl: val } }
        // Name->CC map consistent with engine
        const nameCC = {
          track_volume: 7, track_mute: 9, track_pan: 10,
          param1: 12, param2: 13, param3: 14, param4: 15,
          amp_attack: 20, amp_decay: 21, amp_sustain: 22, amp_release: 23,
          filter_attack: 24, filter_decay: 25, filter_sustain: 26, filter_release: 27,
          voice_mode: 28, portamento: 29, pitchbend_amount: 30, engine_volume: 31,
          cutoff: 32, resonance: 33, env_amount: 34, key_tracking: 35,
          send_ext: 36, send_tape: 37, send_fx1: 38, send_fx2: 39,
          lfo_dest: 40, lfo_param: 41,
        };
        const panel = document.createElement('div'); panel.style.marginTop='12px';
        const title = document.createElement('h3'); title.textContent = 'Automation (live)'; panel.appendChild(title);
        const tracks = root.tracks || [];
        tracks.forEach((tr, ti) => {
          const ch = (typeof tr.midiChannel === 'number') ? tr.midiChannel : 0;
          const lanes = Array.isArray(tr.ccLanes) ? tr.ccLanes : [];
          if (!lanes.length) return;
          const card = document.createElement('div'); card.className='track';
          const h = document.createElement('h3'); h.textContent = (tr.name||tr.id||'Track') + ` (ch ${ch})`; card.appendChild(h);
          lanes.forEach((lane) => {
            const dest = lane.dest; if (dest == null) return;
            // Resolve control number
            let ctrl = null;
            if (typeof dest === 'number') ctrl = dest|0;
            else if (typeof dest === 'string') {
              if (dest.startsWith('cc:')) { ctrl = parseInt(dest.split(':',2)[1]||'0',10)||0; }
              else if (dest.startsWith('name:')) { const nm = dest.split(':',2)[1]||''; ctrl = nameCC[nm] ?? null; }
            }
            if (ctrl == null) return;
            const laneCh = (typeof lane.channel === 'number') ? (lane.channel|0) : ch;
            const liveVal = (ccNow[laneCh] && ccNow[laneCh][ctrl] != null) ? (ccNow[laneCh][ctrl]|0) : null;
            const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.margin='4px 0';
            const label = document.createElement('div'); label.style.width='180px'; label.style.fontSize='12px'; label.style.color='#444';
            label.textContent = `${lane.id||'lane'}  dest=${typeof dest==='string'?dest:('cc:'+ctrl)}  ch=${laneCh}`;
            const barWrap = document.createElement('div'); barWrap.style.flex='1'; barWrap.style.height='8px'; barWrap.style.background='#eee'; barWrap.style.borderRadius='4px';
            const bar = document.createElement('div'); bar.style.height='8px'; bar.style.borderRadius='4px'; bar.style.background='#5aa7ff'; bar.style.width = (liveVal!=null? (Math.round((liveVal/127)*100)) : 0) + '%';
            barWrap.appendChild(bar);
            const val = document.createElement('div'); val.style.width='40px'; val.style.textAlign='right'; val.style.fontFamily='ui-monospace,Menlo,monospace'; val.style.fontSize='12px'; val.textContent = (liveVal!=null? String(liveVal): '—');
            row.appendChild(label); row.appendChild(barWrap); row.appendChild(val);
            card.appendChild(row);
          });
          // Active notes quick summary
          const act = (state.activeNotes && state.activeNotes[ch]) || null;
          const notes = document.createElement('div'); notes.style.fontSize='12px'; notes.style.color='#666'; notes.style.marginTop='4px';
          if (act) { notes.textContent = `active notes: ${act.count}  pitches: ${(act.pitches||[]).join(', ')}`; } else { notes.textContent = 'active notes: 0'; }
          card.appendChild(notes);
          panel.appendChild(card);
        });
        if (!panel.children.length) { const p=document.createElement('div'); p.textContent = 'No ccLanes found in current loop.'; panel.appendChild(p); }
        host.appendChild(panel);

        // LFOs (live) panel
        let lfoNow = Array.isArray(state.lfoNow) ? state.lfoNow : [];
        // Fallback: if runtime hasn't reported live LFOs yet, synthesize from doc so users can see what's configured
        if ((!lfoNow || lfoNow.length===0) && root && Array.isArray(root.tracks)) {
          lfoNow = [];
          root.tracks.forEach((tr, ti) => {
            const ch = (typeof tr.midiChannel==='number')?tr.midiChannel:0;
            const lfos = Array.isArray(tr.lfos) ? tr.lfos : [];
            lfos.forEach(lf => {
              lfoNow.push({
                track: ti, lfoId: String(lf.id||''), destString: (typeof lf.dest==='string'? lf.dest:null),
                destCtrl: (typeof lf.dest==='number'? (lf.dest|0) : null), channel: ch,
                shape: String(lf.shape||'triangle'), rate: lf.rate||{}, depth: (lf.depth|0)||0,
                offset: (lf.offset|0)||64, center: (lf.offset|0)||64, active: false, value: (lf.offset|0)||64,
              });
            });
          });
        }
        const panelLfo = document.createElement('div'); panelLfo.style.marginTop='12px';
        const titleL = document.createElement('h3'); titleL.textContent = 'LFOs (live)'; panelLfo.appendChild(titleL);
        // Group by track index
        const byTrack = new Map();
        for (const ent of lfoNow) { const ti = (typeof ent.track==='number')? (ent.track|0) : -1; if (!byTrack.has(ti)) byTrack.set(ti, []); byTrack.get(ti).push(ent); }
        const tracksArr = root.tracks || [];
        const rateLabel = (rate) => {
          if (!rate || typeof rate !== 'object') return '';
          if (rate.hz != null) { const n=Number(rate.hz)||0; return `${(Math.round(n*100)/100)} Hz`; }
          if (rate.sync != null) { return String(rate.sync); }
          return '';
        };
        const destLabel = (ent) => {
          if (ent.destString) return ent.destString;
          if (ent.destCtrl != null) return 'cc:'+String(ent.destCtrl);
          return '?';
        };
        // Render per-track LFO cards
        Array.from(byTrack.keys()).sort((a,b)=>a-b).forEach(ti => {
          const card = document.createElement('div'); card.className='track';
          const tr = tracksArr[ti] || {}; const ch = (typeof tr.midiChannel==='number')?tr.midiChannel: (byTrack.get(ti)[0]?.channel ?? 0);
          const h = document.createElement('h3'); h.textContent = `${tr.name||tr.id||('Track '+ti)} (ch ${ch})`; card.appendChild(h);
          byTrack.get(ti).forEach(ent => {
            const row = document.createElement('div'); row.style.display='flex'; row.style.alignItems='center'; row.style.gap='8px'; row.style.margin='4px 0';
            const label = document.createElement('div'); label.style.width='320px'; label.style.fontSize='12px'; label.style.color='#444';
            const act = ent.active ? '' : ' (inactive)';
            label.textContent = `${ent.lfoId||'lfo'}  dest=${destLabel(ent)}  ch=${ent.channel}  shape=${ent.shape}  rate=${rateLabel(ent.rate)}${act}`;
            const barWrap = document.createElement('div'); barWrap.style.flex='1'; barWrap.style.height='8px'; barWrap.style.background = ent.active ? '#eee' : '#f3f3f3'; barWrap.style.borderRadius='4px'; barWrap.style.position='relative';
            const bar = document.createElement('div'); bar.style.height='8px'; bar.style.borderRadius='4px'; bar.style.background= ent.active ? '#00b894' : '#bbb'; bar.style.width=(Math.round(((ent.value||0)/127)*100))+'%';
            // center marker
            const center = Math.max(0, Math.min(127, (ent.center||64)));
            const marker = document.createElement('div'); marker.style.position='absolute'; marker.style.left = (Math.round((center/127)*100))+'%'; marker.style.top='-2px'; marker.style.width='2px'; marker.style.height='12px'; marker.style.background='#333'; marker.style.opacity='0.4';
            barWrap.appendChild(bar); barWrap.appendChild(marker);
            const val = document.createElement('div'); val.style.width='48px'; val.style.textAlign='right'; val.style.fontFamily='ui-monospace,Menlo,monospace'; val.style.fontSize='12px'; val.textContent = String(ent.value ?? '—');
            row.appendChild(label); row.appendChild(barWrap); row.appendChild(val);
            card.appendChild(row);
          });
          panelLfo.appendChild(card);
        });
        if (byTrack.size === 0) { const p=document.createElement('div'); p.textContent = 'No LFOs found in current loop.'; panelLfo.appendChild(p); }
        host.appendChild(panelLfo);
      }


      // Controls
      // Transport is device-controlled; UI does not send play/stop
      document.getElementById('btnReconnect').onclick = () => { try { ws && ws.close(); } catch(e){}; connect(); };
      document.getElementById('btnClockInternal').onclick = () => { try { send({type:'setClockSource', source:'internal'}); } catch(e){} };
      document.getElementById('btnClockExternal').onclick = () => { try { send({type:'setClockSource', source:'external'}); } catch(e){} };
      document.getElementById('btnPlay').onclick = () => { try { send({type:'play'}); } catch(e){} };
      document.getElementById('btnStop').onclick = () => { try { send({type:'stop'}); } catch(e){} };
      // Simplified: Push tempo sends CC80 mapping; device remains master
      document.getElementById('btnSetTempo').onclick = () => {
        if (!ws || ws.readyState !== 1) return;
        const bpmField = document.getElementById('bpm');
        const bpm = parseFloat(bpmField.value||'120');
        if (!isFinite(bpm) || bpm <= 0) return;
        // Always send CC80 to device for tempo nudge; device remains master
        ws.send(JSON.stringify({type:'setTempoCC', bpm}));
        try { bpmField.blur(); } catch(e){}
        // Optimistically reflect value for continuity
        try { bpmField.value = (Math.round(bpm * 10) / 10).toFixed(1); } catch(e){}
      };

      // No explicit velocity controls in UI; backend keeps velocity semantics

      connect();
      // Initial draw of automation (empty until first state)
      renderAutomation();
    </script>
  </body>
  </html>
